#!/usr/bin/env python

# Copyright (c) 2010 Citrix Systems, Inc.
# Copyright 2010 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

#
# XenAPI plugin for managing glance images
#

import httplib
try:
    import json
except ImportError:
    import simplejson as json
import os
import os.path
import pickle
import shlex
import shutil
import subprocess
import tempfile

import XenAPIPlugin

#FIXME(sirp): should this use pluginlib from 5.6?
from pluginlib_nova import *
configure_logging('glance')

CHUNK_SIZE = 8192
KERNEL_DIR = '/boot/guest'


def _copy_kernel_vdi(dest, copy_args):
    vdi_uuid = copy_args['vdi_uuid']
    vdi_size = copy_args['vdi_size']
    logging.debug("copying kernel/ramdisk file from %s to /boot/guest/%s",
                  dest, vdi_uuid)
    filename = KERNEL_DIR + '/' + vdi_uuid
    #make sure KERNEL_DIR exists, otherwise create it
    if not os.path.isdir(KERNEL_DIR):
        logging.debug("Creating directory %s", KERNEL_DIR)
        os.makedirs(KERNEL_DIR)
    #read data from /dev/ and write into a file on /boot/guest
    of = open(filename, 'wb')
    f = open(dest, 'rb')
    #copy only vdi_size bytes
    data = f.read(vdi_size)
    of.write(data)
    f.close()
    of.close()
    logging.debug("Done. Filename: %s", filename)
    return filename


def _download_tarball(sr_path, staging_path, image_id, glance_host,
                      glance_port, auth_token):
    """Download the tarball image from Glance and extract it into the staging
    area.
    """
    # Build request headers
    headers = {}
    if auth_token:
        headers['x-auth-token'] = auth_token

    conn = httplib.HTTPConnection(glance_host, glance_port)
    conn.request('GET', '/v1/images/%s' % image_id, headers=headers)
    resp = conn.getresponse()
    if resp.status == httplib.NOT_FOUND:
        raise Exception("Image '%s' not found in Glance" % image_id)
    elif resp.status != httplib.OK:
        raise Exception("Unexpected response from Glance %i" % resp.status)

    tar_cmd = "tar -zx --directory=%(staging_path)s" % locals()
    tar_proc = _make_subprocess(tar_cmd, stderr=True, stdin=True)

    chunk = resp.read(CHUNK_SIZE)
    while chunk:
        tar_proc.stdin.write(chunk)
        chunk = resp.read(CHUNK_SIZE)

    _finish_subprocess(tar_proc, tar_cmd)
    conn.close()


def _import_vhds(sr_path, staging_path, uuid_stack):
    """Import the VHDs found in the staging path.

    We cannot extract VHDs directly into the SR since they don't yet have
    UUIDs, aren't properly associated with each other, and would be subject to
    a race-condition of one-file being present and the other not being
    downloaded yet.

    To avoid these we problems, we use a staging area to fixup the VHDs before
    moving them into the SR. The steps involved are:

        1. Extracting tarball into staging area (done prior to this call)

        2. Renaming VHDs to use UUIDs ('snap.vhd' -> 'ffff-aaaa-...vhd')

        3. Linking VHDs together if there's a snap.vhd

        4. Pseudo-atomically moving the images into the SR. (It's not really
           atomic because it takes place as multiple os.rename operations;
           however, the chances of an SR.scan occuring between the rename()s
           invocations is so small that we can safely ignore it)

    Returns: A list of VDIs.  Each list element is a dictionary containing
    information about the VHD.  Dictionary keys are:
        1. "vdi_type" - The type of VDI. Currently they can be "os_disk" or
           "swap"
        2. "vdi_uuid" - The UUID of the VDI

    Example return: [{"vdi_type": "os_disk","vdi_uuid": "ffff-aaa..vhd"},
                     {"vdi_type": "swap","vdi_uuid": "ffff-bbb..vhd"}]
    """
    def rename_with_uuid(orig_path):
        """Rename VHD using UUID so that it will be recognized by SR on a
        subsequent scan.

        Since Python2.4 doesn't have the `uuid` module, we pass a stack of
        pre-computed UUIDs from the compute worker.
        """
        orig_dirname = os.path.dirname(orig_path)
        uuid = uuid_stack.pop()
        new_path = os.path.join(orig_dirname, "%s.vhd" % uuid)
        os.rename(orig_path, new_path)
        return new_path, uuid

    def link_vhds(child_path, parent_path):
        """Use vhd-util to associate the snapshot VHD with its base_copy.

        This needs to be done before we move both VHDs into the SR to prevent
        the base_copy from being DOA (deleted-on-arrival).
        """
        modify_cmd = ("vhd-util modify -n %(child_path)s -p %(parent_path)s"
                      % locals())
        modify_proc = _make_subprocess(modify_cmd, stderr=True)
        _finish_subprocess(modify_proc, modify_cmd)

    def move_into_sr(orig_path):
        """Move a file into the SR"""
        filename = os.path.basename(orig_path)
        new_path = os.path.join(sr_path, filename)
        os.rename(orig_path, new_path)
        return new_path

    def assert_vhd_not_hidden(path):
        """
        This is a sanity check on the image; if a snap.vhd isn't
        present, then the image.vhd better not be marked 'hidden' or it will
        be deleted when moved into the SR.
        """
        query_cmd = "vhd-util query -n %(path)s -f" % locals()
        query_proc = _make_subprocess(query_cmd, stdout=True, stderr=True)
        out, err = _finish_subprocess(query_proc, query_cmd)

        for line in out.splitlines():
            if line.startswith('hidden'):
                value = line.split(':')[1].strip()
                if value == "1":
                    raise Exception(
                        "VHD %(path)s is marked as hidden without child" %
                        locals())

    def prepare_if_exists(staging_path, vhd_name, parent_path=None):
        """
        Check for existance of a particular VHD in the staging path and
        preparing it for moving into the SR.

        Returns: Tuple of (Path to move into the SR, VDI_UUID)
                 None, if the vhd_name doesn't exist in the staging path

        If the VHD exists, we will do the following:
            1. Rename it with a UUID.
            2. If parent_path exists, we'll link up the VHDs.
        """
        orig_path = os.path.join(staging_path, vhd_name)
        if not os.path.exists(orig_path):
            return None
        new_path, vdi_uuid = rename_with_uuid(orig_path)
        if parent_path:
            # NOTE(sirp): this step is necessary so that an SR scan won't
            # delete the base_copy out from under us (since it would be
            # orphaned)
            link_vhds(new_path, parent_path)
        return (new_path, vdi_uuid)

    vdi_return_list = []
    paths_to_move = []

    image_info = prepare_if_exists(staging_path, 'image.vhd')
    if not image_info:
        raise Exception("Invalid image: image.vhd not present")

    paths_to_move.append(image_info[0])

    snap_info = prepare_if_exists(staging_path, 'snap.vhd',
            image_info[0])
    if snap_info:
        paths_to_move.append(snap_info[0])
        # We return this snap as the VDI instead of image.vhd
        vdi_return_list.append(dict(vdi_type="os", vdi_uuid=snap_info[1]))
    else:
        assert_vhd_not_hidden(image_info[0])
        # If there's no snap, we return the image.vhd UUID
        vdi_return_list.append(dict(vdi_type="os", vdi_uuid=image_info[1]))

    swap_info = prepare_if_exists(staging_path, 'swap.vhd')
    if swap_info:
        assert_vhd_not_hidden(swap_info[0])
        paths_to_move.append(swap_info[0])
        vdi_return_list.append(dict(vdi_type="swap", vdi_uuid=swap_info[1]))

    for path in paths_to_move:
        move_into_sr(path)

    return vdi_return_list


def _prepare_staging_area_for_upload(sr_path, staging_path, vdi_uuids):
    """Hard-link VHDs into staging area with appropriate filename
    ('snap' or 'image.vhd')
    """
    for name, uuid in vdi_uuids.items():
        source = os.path.join(sr_path, "%s.vhd" % uuid)
        link_name = os.path.join(staging_path, "%s.vhd" % name)
        os.link(source, link_name)


def _upload_tarball(staging_path, image_id, glance_host, glance_port, os_type,
                    auth_token):
    """
    Create a tarball of the image and then stream that into Glance
    using chunked-transfer-encoded HTTP.
    """
    conn = httplib.HTTPConnection(glance_host, glance_port)

    # NOTE(dprince): We need to resend any existing Glance meta/property
    # headers so they are preserved in Glance. We obtain them here with a
    # HEAD request.
    conn.putrequest('HEAD', '/v1/images/%s' % image_id)
    if auth_token:
        conn.putheader('x-auth-token', auth_token)
    conn.endheaders()

    resp = conn.getresponse()
    if resp.status != httplib.OK:
        raise Exception("Unexpected response from Glance %i" % resp.status)
    headers = {}
    for header, value in resp.getheaders():
        if header.lower().startswith("x-image-meta-property-"):
            headers[header.lower()] = value

    # Toss body so connection state-machine is ready for next request/response
    resp.read()

    # NOTE(sirp): httplib under python2.4 won't accept a file-like object
    # to request
    conn.putrequest('PUT', '/v1/images/%s' % image_id)

    # NOTE(sirp): There is some confusion around OVF. Here's a summary of
    # where we currently stand:
    #   1. OVF as a container format is misnamed. We really should be using
    #      OVA since that is the name for the container format; OVF is the
    #      standard applied to the manifest file contained within.
    #   2. We're currently uploading a vanilla tarball. In order to be OVF/OVA
    #      compliant, we'll need to embed a minimal OVF manifest as the first
    #      file.
    ovf_headers = {
        'content-type': 'application/octet-stream',
        'transfer-encoding': 'chunked',
        'x-image-meta-is-public': 'False',
        'x-image-meta-status': 'queued',
        'x-image-meta-disk-format': 'vhd',
        'x-image-meta-container-format': 'ovf',
        'x-image-meta-property-os-type': os_type}

    # If we have an auth_token, set an x-auth-token header
    if auth_token:
        ovf_headers['x-auth-token'] = auth_token

    headers.update(ovf_headers)

    for header, value in headers.iteritems():
        conn.putheader(header, value)
    conn.endheaders()

    tar_cmd = "tar -zc --directory=%(staging_path)s ." % locals()
    tar_proc = _make_subprocess(tar_cmd, stdout=True, stderr=True)

    chunk = tar_proc.stdout.read(CHUNK_SIZE)
    while chunk:
        conn.send("%x\r\n%s\r\n" % (len(chunk), chunk))
        chunk = tar_proc.stdout.read(CHUNK_SIZE)
    conn.send("0\r\n\r\n")

    _finish_subprocess(tar_proc, tar_cmd)

    resp = conn.getresponse()
    if resp.status != httplib.OK:
        raise Exception("Unexpected response from Glance %i" % resp.status)
    conn.close()


def _make_staging_area(sr_path):
    """
    The staging area is a place where we can temporarily store and
    manipulate VHDs. The use of the staging area is different for upload and
    download:

    Download
    ========

    When we download the tarball, the VHDs contained within will have names
    like "snap.vhd" and "image.vhd". We need to assign UUIDs to them before
    moving them into the SR. However, since 'image.vhd' may be a base_copy, we
    need to link it to 'snap.vhd' (using vhd-util modify) before moving both
    into the SR (otherwise the SR.scan will cause 'image.vhd' to be deleted).
    The staging area gives us a place to perform these operations before they
    are moved to the SR, scanned, and then registered with XenServer.

    Upload
    ======

    On upload, we want to rename the VHDs to reflect what they are, 'snap.vhd'
    in the case of the snapshot VHD, and 'image.vhd' in the case of the
    base_copy. The staging area provides a directory in which we can create
    hard-links to rename the VHDs without affecting what's in the SR.


    NOTE
    ====

    The staging area is created as a subdirectory within the SR in order to
    guarantee that it resides within the same filesystem and therefore permit
    hard-linking and cheap file moves.
    """
    staging_path = tempfile.mkdtemp(dir=sr_path)
    return staging_path


def _cleanup_staging_area(staging_path):
    """Remove staging area directory

    On upload, the staging area contains hard-links to the VHDs in the SR;
    it's safe to remove the staging-area because the SR will keep the link
    count > 0 (so the VHDs in the SR will not be deleted).
    """
    shutil.rmtree(staging_path)


def _make_subprocess(cmdline, stdout=False, stderr=False, stdin=False):
    """Make a subprocess according to the given command-line string
    """
    kwargs = {}
    kwargs['stdout'] = stdout and subprocess.PIPE or None
    kwargs['stderr'] = stderr and subprocess.PIPE or None
    kwargs['stdin'] = stdin and subprocess.PIPE or None
    args = shlex.split(cmdline)
    proc = subprocess.Popen(args, **kwargs)
    return proc


def _finish_subprocess(proc, cmdline):
    """Ensure that the process returned a zero exit code indicating success
    """
    out, err = proc.communicate()
    ret = proc.returncode
    if ret != 0:
        raise Exception("'%(cmdline)s' returned non-zero exit code: "
                        "retcode=%(ret)i,  stderr='%(err)s'" % locals())
    return out, err


def download_vhd(session, args):
    """Download an image from Glance, unbundle it, and then deposit the VHDs
    into the storage repository
    """
    params = pickle.loads(exists(args, 'params'))
    image_id = params["image_id"]
    glance_host = params["glance_host"]
    glance_port = params["glance_port"]
    uuid_stack = params["uuid_stack"]
    sr_path = params["sr_path"]
    auth_token = params["auth_token"]

    staging_path = _make_staging_area(sr_path)
    try:
        _download_tarball(sr_path, staging_path, image_id, glance_host,
                          glance_port, auth_token)
        # Right now, it's easier to return a single string via XenAPI,
        # so we'll json encode the list of VHDs.
        return json.dumps(_import_vhds(sr_path, staging_path, uuid_stack))
    finally:
        _cleanup_staging_area(staging_path)


def upload_vhd(session, args):
    """Bundle the VHDs comprising an image and then stream them into Glance.
    """
    params = pickle.loads(exists(args, 'params'))
    vdi_uuids = params["vdi_uuids"]
    image_id = params["image_id"]
    glance_host = params["glance_host"]
    glance_port = params["glance_port"]
    sr_path = params["sr_path"]
    os_type = params["os_type"]
    auth_token = params["auth_token"]

    staging_path = _make_staging_area(sr_path)
    try:
        _prepare_staging_area_for_upload(sr_path, staging_path, vdi_uuids)
        _upload_tarball(staging_path, image_id, glance_host, glance_port,
                        os_type, auth_token)
    finally:
        _cleanup_staging_area(staging_path)

    return ""  # Nothing useful to return on an upload


def copy_kernel_vdi(session, args):
    vdi = exists(args, 'vdi-ref')
    size = exists(args, 'image-size')
    #Use the uuid as a filename
    vdi_uuid = session.xenapi.VDI.get_uuid(vdi)
    copy_args = {'vdi_uuid': vdi_uuid, 'vdi_size': int(size)}
    filename = with_vdi_in_dom0(session, vdi, False,
                                lambda dev:
                               _copy_kernel_vdi('/dev/%s' % dev, copy_args))
    return filename


def remove_kernel_ramdisk(session, args):
    """Removes kernel and/or ramdisk from dom0's file system"""
    kernel_file = optional(args, 'kernel-file')
    ramdisk_file = optional(args, 'ramdisk-file')
    if kernel_file:
        os.remove(kernel_file)
    if ramdisk_file:
        os.remove(ramdisk_file)
    return "ok"


if __name__ == '__main__':
    XenAPIPlugin.dispatch({'upload_vhd': upload_vhd,
                           'download_vhd': download_vhd,
                           'copy_kernel_vdi': copy_kernel_vdi,
                           'remove_kernel_ramdisk': remove_kernel_ramdisk})
